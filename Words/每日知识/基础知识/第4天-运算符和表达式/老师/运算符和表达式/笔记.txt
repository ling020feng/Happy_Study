运算符和表达式组成了c程序的基本语句

运算符的几目运算符表示什么意思呢？
	单目运算符：表示运算符链接一个操作数
	双目运算符：表示运算符链接两个操作数
	三目运算符：表示运算符链接三个操作数
	
运算符的结合性：
	计算在对数据进行处理时，不可能同时处理两个数据（单cpu）
	因此，设计到多目运算符时，这几个操作数到底先执行哪一个呢？
	从左往右结合：先运算左边的操作数，在运算右边的操作数
		a + b; a的值去加上b的值 
		b + a; b的值去加上a的值
	从右往左结合：先运算右边的操作数，再运算左边的操作数
		a = b; 将b的值赋值给a的地址

	多个运算符在一个表达式中时，结合性看各类运算符的优先级
优先级：
	单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符>逗号运算符
	如果您实在记不住这些优先级怎么办？？
	()括号是很有帮助了	
	2+1*3 = 5;
	(2+1)*3 = 9;

	
运算符：对数据进行操作的符号被称为运算符
	算术运算符：算术运算符是用来进行某种算术运算的
		单目： ++  -- 自运算符
			用法： 左值++  ++左值
				   左值--  --左值
			由于++ 和 -- 会改变操作数的值，
				因此操作数必须是一个可读可写的地址（左值）
				
			int a = 3;
			int b = 4;
			a++；
			b--;
			(a+b)++; //详见1.c
			
					表达式的值         运算完成后的结果
		i++				i					i+1
		++i				i+1					i+1
		i--				i					i-1
		--i             i-1					i-1
		//详见2.c
		规律：自运算符在前则先 加/减 再运算
			  自运算符在后则先运算在加/减
		双目：+ - * / % ....
		整数的运算结果只会是整数
		
		a+++b //见2.c
		
		a++++;
		++a++;
		++++a;
		上面三个都是错误的，错误原因都是第二次++时
			已经不是对左值操作了！！！
		
		5/2=2;
		5.2%2这中表达式是错误的，
			%符两边只能是整数
			
		/和% 右边的数不能为0
		5/0   5%0
		
		对于/运算符，如果两边都是整数，此运算符为取整运算
					如果说左边是浮点型，并且运算结果赋值给浮点型
					此运算符做 算术除
			
		int a = 5.2/2;	  a = 2;
		float a = 5.2/2;  a == 2.6
		
		float a = 3.5 + 3.6/2;  
		int a = 3.5 + 3.6/2;
		
	关系运算符：用来比较数据的关系
		双目运算符，结合性从左到右
		<   <=  > >= == !=  
		注意：在c语言中逻辑表达式与数学中的逻辑表达式不能通用
		比如：
			数学表达式：10<x<100; x要大于10并且小于100
			这种表达式在c语言中是不被识别的
			c语言将上述表达式识别为：
				10<x 如果为真，其值为1， 1<100 => 1
					 如果为假，其值为0,  0<100 => 1
		关系表达式的结果有两种
			如果表达式为真，表达式的值等于1
			如果表达式为假，表达式的值等于0
			
		int a = 5;
		int b = a > 4 > 3;
		printf("%d\n",b); //0
					 
				
	逻辑运算符：双目运算符  结合性从左到右
		非0即为真
		0为假
		&&　　逻辑与:有0为0,全1为1
		||    逻辑或:有1为1,全0为0
		!	  逻辑非(单目运算符):真为假,假为真
		
		在c语言中,运算是具有惰性的!!!
		1 && 2 && 3 && 4
		0 && 1 && 2 && 3 && ......
		如果说,前面的操作数已经能够得出表达式的结果了,
			那么计算机不会去运算后面的操作数,这就是惰性
	int a,b,c,d,m,n;
	a = 1;b = 2; c = 3;d = 4;
	(m = a>b) && (n = c > d);
	printf("a=%d b=%d c=%d d=%d m=%d n=%d\n",a,b,c,d,m,n);
		
			对于 && 来说
			表达式        结果
			1 && 1         1
			1 && 0 		   0
			0 && 1 		   0
			0 && 0		   0
			1 && x		   x
			0 && x		   0
			
			1逻辑与上任意一个数，其表达式由 ”任意一个数“决定
			0逻辑与上任意一个数，其表达式的值都为 0（惰性）
			
			对于 || 来说
			表达式         结果
			1 || x			1
			0 || x			x
			0逻辑或上任意一个数，其表达是由”任意一个数“决定
			1逻辑或上任意一个数，其表达式的值都为1（惰性）
			
			对于 ! 来说
			!0    为真
			!1    为假
			
			a && b || !c 
			运算过程：
				a && b 如果为 真 则表达式值为 1
	练习：
		1、
		int a = 3;
		int b = 4;
		int c = a || b+a && b-a || a++;
		printf("a=%d b=%d c=%d\n",a,b,c);//  3 4 1
		
		2、
		int a = 1;
		int b = -1;
		a = a<b || a>b && b==a&&b;
		printf("a=%d b=%d\n",a,b);
		
		3、
		int a = 1;
		int b = 1;
		int c = --a || b&&a-- > 0;//b&&a-- >0 先运算 a-- > 0?
		printf("c=%d\n",c);
		
		
		int i = 3;
				
		int a = i++ + i++ + i++ + i++ + i++ + i++ + i++;
		printf("i=%d a=%d\n",i,a);// 10 21?
		编程的时候，避免使用上述操作
		不同的编译器的解释方式不同
		
		设y是1-2018年中的某一年
			试用逻辑表达式，写出一个判断y是不是闰年的表达式
			（1）y能被4整除，但不能被100整除
					y%4==0 && y%100!=0 
			（2）y能被4整除，并且能被400整除 
					y%4==0 && y%400==0
			满足以上两个条件中的任意一个，那么y都是闰年
		
		int main(void)
		{
			int y = 1234;
			/*
			if(y%4==0 && y%100!=0)
				printf("%d 是闰年\n");
			if(y%4==0 && y%400==0)
				printf("%d 是闰年\n");
			*/
			if((y%4==0 && y%100!=0) || (y%4==0 && y%400==0))
		}
		逻辑关系符中：! > && > ||
		
		
	位运算符：按照bit位进行运算的操作符
		对于位操作来说，被操作的数只能是整数
		（整型、短型、长型、字符型）
		在进行位运算时，需要先将整数转换位二进制数在操作
		&:按位与
			1 & 1 = 1
			1 & 0 = 0
			0 & 1 = 0
			0 & 0 = 0
			
		比如：	
			int a = 3;
			int b = 4;
			int c = a & b; //0
			过程：
			00000000 00000000 00000000 00000011 (3)
			00000000 00000000 00000000 00000100 (4)
		   &00000000 00000000 00000000 00000000 (0)	
		用途：	
		（1）按位与常用与就将一个数的某些位取出来
			比如 将 0x89abcdef 的第 12位到第18位取出来（标号从0开始）
			
				1000 1001 1010 1011 1100 1101 1110 1111 （0x89abcdef）
			   &0000 0000 0000 0111 1111 0000 0000 0000	 (0x0007f000)
				0000 0000 0000 0011 1100 0000 0000 0000  (0x3c000)
			练习：有1个数是0x12345，要求取出第9位
			 0x12345 & 0x200 = 0x200;
			 
			 要取出某几个比特位，就是按位与上一个对应位为1的数
		（2）清0指定位：按位与上对应位为0，并且其它位为1的数
			char a = 0xff; //清零低4位
			思路：清零低4位也就是说，低4位为0，其它位为1
			---》所以这个数是 1111 0000 (0xf0)
				1111 1111 （0xff）
			  &	1111 0000 （0xf0）
			  ————————————————————
				1111 0000 （0xf0）
				
				清零 0x34的 第3到第6位  1000 0111 (0x87)
				0011 0100  (0x34)
			  &	1000 0111  (0x87)
			 ————————————————————
				0000 0100  (0x4)
		(3)保留指定位：按位与上对应位为1的数，并且其它位为0
			
		练习：1、取出int a = 1234; 的 第5到第11位
				1234 = 1024 + 128 + 64 + 16 + 2
				0000 0000 0000 0000 0000 0100 1101 0010 (1234)
			  &	0000 0000 0000 0000 0000 1111 1110 0000 (0xfe0)
				0000 0000 0000 0000 0000 0100 1100 0000 (0x4c0)
			  2、清0取出来的数的第8和10位(第8和10位为0，其它位为1)
				0x4c0 & x;
				0000 0000 0000 0000 0000 0100 1100 0000 (0x4c0)
			  &	1111 1111 1111 1111 1111 1010 1111 1111 
			    0000 0000 0000 0000 0000 0000 1100 0000 （0xc0）
				
			  3、 9 & 5 =？
				  0000 1001 (9)
				 &0000 0101 (5)
				  0000 0001 (1)
				  
				  182 & 37 = ？
				  1011 0110 (182)
				 &0010 0101 (37)
				  0010 0100 (36)
				  
				  -15 & 3 = ？
				  |-15|:
				  0000 1111  (15)
				  1111 0000  (取反)
				  1111 0001  (-15)
				 &0000 0011   (3)
				  0000 0001   (1)
				  
			按位与操作：
				按位与1保持不变
				按位与0为0
				
		|：按位或
			1 | 1 = 1
			1 | 0 = 1
			0 | 1 = 1
			0 | 0 = 0
			按位或操作：
				 或1为1
				 或0保持不变
			常用来将指定位置1
			比如：char c = 0x01 | 0xf0;
				  0000 0001  （0x01）
				| 1111 0000   (0xf0)
				——————————————————
				  1111 0001   （0xf1）
		   5 | 9 = ?
		   0000 0101  (5)
		 | 0000 1001  (9)
		 ————————————————
		   0000 1101  (13  0xd)
		   
		 练习：将0x12345678的最高16位置1  | 0xffff0000
				同时最低8位置0 & 0xffffff00 
			0001 0010 0011 0100 0101 0110 0111 1000 （0x12345678）	
		|   1111 1111 1111 1111 0000 0000 0000 0000	 （0xffff0000）	
		&	1111 1111 1111 1111 1111 1111 0000 0000  (0xffffff00)	
			1111 1111 1111 1111 0101 0110 0000 0000	 (0xffff5600)
		////////////////////////////////////////////////////////// 
		 求 0x12345678 | 0xffff0000 & 0xffffff00 = ?
			0x12345678 | 0xffff0000
			0xffff5678		 
		 提示：同类运算符同样具有优先级  & > |
		
		~：按位取反（非）,单目运算符，除~以外都是双目运算符
			~1 = 0；
			~0 = 1；
			  ~10086 = ？
			 0000 0000 0000 0000 0010 0111 0110 0110 （10086）
			 1111 1111 1111 1111 1101 1000 1001 1001  （~10086）
			 
		^：按位异或（求异）：不同为1 相同为0
			1 ^ 0 = 1
			1 ^ 1 = 0
			0 ^ 1 = 1
			0 ^ 0 = 0
			与1按位异或翻转
			与0按位异或保持不变
			作用：一般用来将特定位置翻转
					翻转---》0变1 1变0
					
					比如：将char a = 0x12;的高4位翻转
					  方法：让高4位异或1，低4位异或0
					   0x12 ^ 0xf0 = 
					   0001 0010 (0x12)
					  ^1111 0000 (0xf0)
					   1110 0010 (0xe2)
				  交换两个数的位置
				  比如：char a = 5;
						char b = 9;
						------> a = 9; b = 5;
						a = a^b;
							0000 0101  (a 5)
						   ^0000 1001  (b 9)
							0000 1100  (a 12)
						b = a^b;
							0000 1100  (a 12)
						   ^0000 1001  (b 9)
						    0000 0101  (b 5)
						a = a^b;
							0000 1100  (a 12)
						   ^0000 0101  (b 5)
						    0000 1001  (a 9)
		记住一点：：：位操作是将整数转换成二进制位再一位一位的操作
	作业：
		1、分别用算术表达式 和 位运算 将两个数不借助第三个数转换位置
			比如：
				char a = 77;
				char b = 88;
				 ----> a = 88; b = 77;
				 
		2、char a = 253;
		   char b = a + 255;
		   printf("%d\n",b);
		   printf("%u\n",b);
		   
		3、int a = 0x13579;
		   int b = 0x24680;
		   求 ~a ^ b | a & b
		
		~ > & > ^ > |
	
		按位与：与1相与（按位与） 保持不变
				与0相与（按位与） 为0
		按位或：与1相或（按位或） 为1
				与0相或（按位或） 保持不变
		按位异或：相同为0
				  相异位1
		按位取反：取反1为0
				  取反0为1
				
		<<：按位左移
			表示将整数转换为二进制后，向左边移动
			b31 b30 b29 b28 b27 …… b3 b2 b1 b0
			<<1:
			b30 b29 b28 b27 b26 …… b2 b1 b0 0	
			<<2:
			b29 .................   	 0  0
			....
			b<<31
			b0 0 0 0 0 0 0 0 0 0.....   000000
			按位左移：高位舍弃，低位补0
			比如：(int) 2<<8 = ?
			00000000 00000000 00000000 00000010  （2）
			00000000 00000000 00000010 00000000   (2*2的8次方)
			
			8<<24位：
			00000000 00000000 00000000 00001000  （8）
			00001000 00000000 00000000 00000000   (8*2的24次方)
			
			m<<n位：
			m*2的n次方
			
			如果左移n位舍弃的都是0，那么左移后的结果就是
			原来的数乘以2的n次方
			
		>>：按位右移
			按位右移：低位舍弃，
					  高位：如果是有符号的，则高位补符号位
							如果是无符号的，高位补0
			37>>8
			00000000 00000000 00000000 00100101 (37)
			00000000 00000000 00000000 00000000 （0）
			
			char a = 0x81;
			char c = a>>8;
			printf("%d\n",c); //-1
			printf("%u\n",c); //2^32-1
			1000 0001 (0x81)
			1111 1111 (0xff)
			
	注意： 2^32 ----->在c程序中表示的是 2 按位异或 32
		char a = 0x12;
		char b = 0x34;
		char c = 0x56;
		char d = 0x78;
		如果此时有一个数 int t； t=0x12345678;
		那么如果通过 abcd获得t；
		t = d;
			00000000 00000000 00000000 01111000 （ t = d）;
		c << 8
			00000000 00000000 01010110 00000000 
		b << 16
			00000000 00110100 00000000 00000000
		a << 24
			00010010 00000000 00000000 00000000
		
		t = d | c<<8 | b << 16 | a << 24;
		
		
		char a = 0x81//0x21;
		char b = 0x82/0x43;
		char c = 0x83//0x65;
		char d = 0x84//0x87;
		如果此时有一个数 int t； t=0x81828384 //0x21436587;
		那么如果通过 abcd获得t；
		printf("0x%x\n",t); //0xffffff87
		t = d&0xff | (c&0xff)<<8 | (b&0xff)<<16 | (a&0xff)<<24;
		t = d	+		c*256    +     b*256*256 + a*256*256*256;
		//a = 1+2*10+3*100+4*1000;//
			qian = a/1000;
			bai = a%1000/100;
			shi = a%1000%100/10;
			ge = a%10
			
		0x12<<24 ----> 0x12 * (2的24次方)
			
			
	练习：1、计算 4096<<17=?
		  2、写一个程序，从键盘获取一个int型的数，
			 分别将各个字节赋值给一个char型
			 （1）、求余与取整结合使用
					char a,b,c,d;
					a = t/(256*256*256);
					b = t%(256*256*256)/(256*256)；
					....
					
			 （2）、取出指定位
					a = t>>24&0xff;
					b = t>>16&0xff;
					....
			 
			 int t;
			 scanf("%d",&t);
			 scanf("%x",&t);
			 printf("0x%x\n",t);
			 
			
		
	赋值运算符：给一个左值（变量对应的地址）赋予一个右值（变量的值/数据）
		优先级仅高于逗号运算符，结合从由往左
		= 直接赋值
		+= 加后赋值
		-= 减后赋值
		*= 乘后赋值
		/= 除后赋值
		%= 取余后赋值
		<<= 按位左移赋值
		>>= 按位右移赋值
		&=  按位与后赋值
		|=  按位或后赋值
		~=  按位取反后赋值
		^=	按位异或后赋值
		int a = 5;
		a eo= 3;  //eo表示赋值符前的运算符
		a = a eo 3;
		比如：如果eo为+
		a += 3;
		a = a+3;//8
		
		a ^= 3;
		a = a^3; // 0101 
				 // 0011
				 // 0110 (6)
				 
		int a = 3;
		a+=(a-=(a*=a));
		a+=(a-=(a = a*a));//
		a+=(a -= a);//a = 9;
		a+=(a = a-a);//a = 0;
		a = a+a; //a = 0;	
		
		
	逗号运算符：优先级最低，结合性从左到右
		int i,j,k;
		int main(int argc,char *argv)
		
		x=a=3,6*a //表达式值为 最后一个逗号操作数的值
		
	条件运算符：结合性 从右往左 三目运算符
		？：
		格式：expressions?a:b
		判断表达式是否为真
			如果为真（非0即为真），则表达式的值为a
			如果为假（0），则表达式的值为b
			
		expressions1?a:（expressions2?b:c）
		
		a<b?a:(c<d?a:d)
		--->a<b?a:a
		
	指针运算符：单目运算符
		*取值符
			char *p;
			*p;//取指针p的值
			//p*p； p乘以p
		&取址符
		
	求字节运算符：
		sizeof(int) = 4
		如果求指针的大小：恒为4个字节
		如果求 *指针 的大小：就是指针类型的大小
		char *p = "hello";  '\0'
		sizeof(p);//4  p是一个指针
		sizeof(*p);//1 *p = 'h';
		
		int *t;
		sizeof(t);//4
		sizeof(*t);//4  int型
		
		long *l;
		sizeof(l); // 4 指针
		sizeof(*l); // 8 long
		

		
	强转运算符：
		(数据类型)变量:将变量强转成 数据类型 对应的类型
		char a；
		printf("%d\n",(int)a);
		
		char *p = "abcd";
		int *t = (int*)p;
		
	分量运算符：在结构体中用来访问结构体成员
		. : 对象.成员 
		->: 对象指针->成员
		
	下标运算符：
		用法1:在定义数组的时候,用[]中的数据来表示数组的空间大小
			比如 ： int a[10]; 表示有一个int型数组，
							它的空间是 10个int型空间
		用法2：用来访问数组成员
				a[0]  表示a数组的第1个成员
				...
				a[n]  表示a数组的第n+1个成员
				------》 int a[n+1];
							
	其它运算符：
		函数调用运算符
		返回值 = 函数名(有无成函数传递);//函数调用表达式
		函数调用表达式的值是什么？？？
		函数调用表达式的值就是执行该函数后的那个返回值
			也就是return 后面接的那个表达式的值
		
		比如说，您老师很喜欢在main函数最后面写一个
		return 0;
		这个0就是main函数的返回值
		
		为什么返回0呢？
		这是程序界的一个潜规则，在函数返回值是int型的时候
		返回0表示程序运行没有错误
		返回-1表示程序运行是错误结束的
		
		
		

表达式：表达某种意思的句子被称为表达式
	在c语言中表达式一般指用运算符和操作数组成的式子
	是一个表达式就一定会有一个值，表达是的值就是“某种意思”
	
	
单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符>逗号运算符	
	
	[] () . ->  (强转) -负号
	单目运算符
	算术运算符：* / %
				+ -
	左右移位运算符： <<   >>
	关系运算符： >  <  >=  <=
				==  !=
	位运算符：	&
				^
				|
	逻辑运算符：&&   并且
	            ||   或者
	条件运算符
	
	赋值运算符
	
	逗号运算符
	
	
	编程建议：在涉及到优先级时，又不能确定谁优先级高，那么用括号来解决问题
	
	
	
练习题：
	1-5  DDCCB
	6-10 DDBAB
	11-15 DBCAD
	
	
	f = 3.2,1.0  现将3.2赋值给f，在运算,1.0
	f = (3.2,1.0) 先运算 3.2,1.0在将结果赋值给f 
	
	
符号常量的定义(宏定义)： 用一个符号来表示一个常量
#define PI 3.14	
宏定义的符号一般是大写的
格式：
#define 符号名 常量表达式

int a = 5;
1.0 * a/(b*c)

